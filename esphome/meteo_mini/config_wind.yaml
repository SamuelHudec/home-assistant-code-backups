substitutions:
  device_name: meteo_station

esphome:
  name: ${device_name}
  friendly_name: Meteo station

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: !secret MS_api_encryption_key

ota:
  - platform: esphome
    password: !secret MS_ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Meteo-Station Fallback Hotspot"
    password: !secret MS_ap_fallback_password

captive_portal:

web_server:
  port: 80

i2c:
  sda: 19
  scl: 18
  scan: true
  id: bus_a

# Enable I2C power
switch:
  - platform: gpio
    pin: GPIO3
    id: my_output
    restore_mode: ALWAYS_ON  # Keep the pin high after boot

sensor:
  - platform: bme680
    temperature:
      name: "${device_name} Temperature"
      id: "${device_name}_Temperature"
    pressure:
      name: "${device_name} Pressure"
      id: "${device_name}_Pressure"
    humidity:
      name: "${device_name} Humidity"
      id: "${device_name}_Humidity"
    gas_resistance:
      name: "${device_name} Gas Resistance"
      id: "${device_name}_Gas_Resistance"
    address: 0x77
    update_interval: 60s

  - platform: pulse_counter
    pin: GPIO4  # nastav podľa zapojenia
    name: "${device_name} Wind Speed"
    id: wind_speed_raw
    update_interval: 10s
    internal: true
    filters:
      - multiply: 2.4  # (napr. 2.4 km/h na 1 Hz)
  - platform: template
    name: "${device_name} Wind Speed Avg"
    id: wind_speed_avg
    unit_of_measurement: "km/h"
    icon: "mdi:weather-windy"
    lambda: |-
      return id(wind_speed_raw).state;
    filters:
      - sliding_window_moving_average:
          window_size: 3
          send_every: 1
  - platform: adc
    pin: GPIO5
    name: "${device_name} Wind Direction"
    update_interval: 60s
    filters:
      - lambda: |-
          float voltage = x;
          if (voltage < 0.5) return 0;     // North
          else if (voltage < 1.0) return 45;
          else if (voltage < 1.5) return 90;
          else if (voltage < 2.0) return 135;
          else if (voltage < 2.5) return 180;
          else if (voltage < 3.0) return 225;
          else if (voltage < 3.5) return 270;
          else return 315;                 // West-Northwest etc.
    unit_of_measurement: "°"
    icon: "mdi:compass"

  - platform: adc
    pin: GPIO0
    name: "${device_name} Battery Level"
    id: "${device_name}_Battery_Level"
    entity_category: diagnostic
    filters:
      - multiply: 1.7693877551

  - platform: template
    name: "${device_name} Battery Percent"
    id: "${device_name}_Battery_Percent"
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    update_interval: 60s
    lambda: |-
      float voltage = id(${device_name}_Battery_Level).state;
      float percent = (voltage - 3.0f) / (4.2f - 3.0f) * 100.0f;
      percent = std::clamp(percent, 0.0f, 100.0f);
      return percent;

  - platform: wifi_signal
    name: "${device_name} WiFi Signal"
    update_interval: 60s
    entity_category: "diagnostic"

text_sensor:
  - platform: wifi_info
    ip_address:
      name: "Meteo Mini IP"
